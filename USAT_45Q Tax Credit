// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/finance/PaymentSplitterUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";

interface IFractionalShares {
    function initialize(string memory name, string memory symbol) external;
    function mint(address to, uint256 amount) external;
    function burn(address from, uint256 amount) external;
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
}

contract FractionalShares is ERC20Upgradeable, IFractionalShares {
    function initialize(string memory name, string memory symbol) public initializer {
        __ERC20_init(name, symbol);
    }
}

contract USAT45QTaxCreditsNFTUpgradeable is Initializable, ERC721EnumerableUpgradeable, OwnableUpgradeable, AccessControlUpgradeable, ReentrancyGuardUpgradeable, PaymentSplitterUpgradeable, UUPSUpgradeable, PausableUpgradeable {
    using CountersUpgradeable for CountersUpgradeable.Counter;
    using AddressUpgradeable for address;

    CountersUpgradeable.Counter private _tokenIdCounter;
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant AUCTIONEER_ROLE = keccak256("AUCTIONEER_ROLE");
    bytes32 public constant FRACTIONALIZER_ROLE = keccak256("FRACTIONALIZER_ROLE");

    mapping(uint256 => address) private _fractionalizedTokens;

    struct NFTMetadata {
        string assetRequirement;
        string assetDescription;
        string market;
        string assetPrice;
        string usatScore;
    }

    mapping(uint256 => NFTMetadata) private _tokenMetadata;

    event NFTMinted(uint256 indexed tokenId, address indexed owner, NFTMetadata metadata);
    event NFTFractionalized(uint256 indexed tokenId, address sharesTokenAddress, uint256 sharesAmount);
    event NFTDefractionalized(uint256 indexed tokenId);

    function initialize(
        string memory name,
        string memory symbol,
        address[] memory payees,
        uint256[] memory shares_
    ) public initializer {
        __ERC721Enumerable_init();
        __ERC721_init(name, symbol);
        __Ownable_init();
        __AccessControl_init();
        __ReentrancyGuard_init();
        __PaymentSplitter_init(payees, shares_);
        __UUPSUpgradeable_init();
        __Pausable_init();

        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(AUCTIONEER_ROLE, _msgSender());
        _setupRole(FRACTIONALIZER_ROLE, _msgSender());
    }

    function mintNFT(
        address to,
        NFTMetadata memory metadata
    ) external onlyRole(MINTER_ROLE) {
        _tokenIdCounter.increment();
        uint256 newItemId = _tokenIdCounter.current();

        _mint(to, newItemId);
        _tokenMetadata[newItemId] = metadata;

        emit NFTMinted(newItemId, to, metadata);
    }

    function fractionalizeNFT(uint256 tokenId, uint256 sharesAmount, string memory sharesName, string memory sharesSymbol) external onlyRole(FRACTIONALIZER_ROLE) whenNotPaused {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        require(_fractionalizedTokens[tokenId] == address(0), "NFT is already fractionalized");
        require(ownerOf(tokenId) == _msgSender(), "Caller is not the owner");

        FractionalShares sharesToken = new FractionalShares();
        sharesToken.initialize(sharesName, sharesSymbol);
        sharesToken.mint(_msgSender(), sharesAmount);

        _fractionalizedTokens[tokenId] = address(sharesToken);
        _transfer(_msgSender(), address(this), tokenId);

        emit NFTFractionalized(tokenId, address(sharesToken), sharesAmount);
    }

    function defractionalizeNFT(uint256 tokenId) external onlyRole(FRACTIONALIZER_ROLE) whenNotPaused {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        address sharesTokenAddress = _fractionalizedTokens[tokenId];
        require(sharesTokenAddress != address(0), "NFT is not fractionalized");

        IFractionalShares sharesToken = IFractionalShares(sharesTokenAddress);
        uint256 totalShares = sharesToken.totalSupply();
        require(sharesToken.balanceOf(_msgSender()) == totalShares, "Caller does not own all shares");

        sharesToken.burn(_msgSender(), totalShares);
        _transfer(address(this), _msgSender(), tokenId);

        _fractionalizedTokens[tokenId] = address(0);
        emit NFTDefractionalized(tokenId);
    }

    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _unpause();
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {
        require(newImplementation.isContract(), "New implementation is not a contract");
    }

    // Additional helper functions and logic can be implemented as necessary
}
